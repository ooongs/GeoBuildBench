# DSL Quick Reference Guide

## Basic Syntax

Every DSL line follows: `command : inputs -> outputs`

## Commands by Category

### 1. Points
```
point :  -> A                    # Random point
point : 100 150 -> P             # Fixed coordinates (x, y) - inline numeric literals!
point : 0 0 -> Origin            # Integer coordinates
point : 50.5 86.7 -> P           # Float coordinates (precision preserved!)
point : mx my -> P               # From measure variables
point : circle -> P              # Random point on circle
point : line -> P                # Random point on line
```

**Note**: 
- Numeric literals with decimals are stored as `float` (e.g., `50.5`)
- Numeric literals without decimals are stored as `int` (e.g., `100`)
- Both work seamlessly with geometric functions
- For `Measure` type, use explicit `const Measure X -> label`

### 2. Lines
```
line : A B -> line_AB            # Line through two points
line_bisector : A B -> bisector  # Perpendicular bisector
```

### 3. Segments
```
segment : A B -> seg_AB          # Segment from A to B
```

### 4. Rays
```
ray : A B -> ray_AB              # Ray from A through B
```

### 5. Circles
```
circle : O A -> circle_O         # Center O, passes through A
circle : O radius -> circle_O    # Center O, radius (variable)
circle : O 50 -> circle_O        # Center O, radius 50 (inline literal)
```

### 6. Polygons (DO NOT USE POLYGON COMMAND!)
```
# ❌ FORBIDDEN - Do NOT use polygon command:
# polygon : A B C -> poly1 c a b   # DON'T DO THIS!

# ✅ CORRECT - Always create explicit segments:
segment : A B -> AB              # Triangle side 1
segment : B C -> BC              # Triangle side 2
segment : C A -> CA              # Triangle side 3

# For quadrilateral ABCD:
segment : A B -> AB
segment : B C -> BC
segment : C D -> CD
segment : D A -> DA
```

### 7. Angles
```
angle : A B C -> angle_ABC       # Angle at B from A to C
const int 90 -> deg              # Angle value
```

### 8. Rotations
```
rotate : P deg Center -> P_rot   # Rotate P by deg around Center
rotate : P angle Center -> P_rot # Rotate by angle object

# How to write angles:
rotate : P 90° Center -> P_rot   # 90 degrees (degree)
rotate : P 45.5° Center -> Q     # 45.5 degrees (degree)
rotate : P 1.5708rad Center -> Q # 1.5708 radians (radian)
rotate : P 1.5708r Center -> Q   # short notation (r = radian)
rotate : P 90 Center -> Q        # general number = degree (default)
```

**Angle notation rules**:
- `90°` → degree (degree unit)
- `1.5708rad` → radian (radian unit)
- `1.5708r` → radian (short notation)
- `90` → degree (default, backward compatibility)

### 9. Intersections
```
intersect : line1 line2 -> P     # Intersection of two lines
intersect : line circle -> P     # Line-circle (may return 2 points)
```

### 10. Perpendicular/Parallel
```
orthogonal_line : P line -> perp    # Perpendicular line through P
parallel_line : P line -> para      # Parallel line through P
parallel_line : P segment -> para   # Parallel to segment through P
parallel_line : P ray -> para       # Parallel to ray through P
```

### 11. Midpoints
```
midpoint : A B -> M              # Midpoint of segment AB
```

### 12. Measurements & Constants
```
distance : A B -> dist           # Distance between points
const int 50 -> value            # Integer constant (explicit)
const Measure 10 -> length       # Measure constant (explicit)

# OR use inline numeric literals (precision preserved):
point : 100 200 -> P             # Integers: 100, 200
point : 50.5 86.7 -> Q           # Floats: 50.5, 86.7 (precision preserved!)
circle : O 30.5 -> c             # Float radius: 30.5

# Inline angles with units:
rotate : P 90° Center -> Q       # 90 degrees (° symbol)
rotate : P 45.5° Center -> R     # 45.5 degrees (precision preserved!)
rotate : P 1.5708rad Center -> S # 1.5708 radians (explicit radian)
rotate : P 90 Center -> T        # 90 degrees (default = degree)
```

### 12.1 Mathematical Expressions (NEW!)
```
# You can now use mathematical expressions directly in DSL!
# Supports: +, -, *, /, (), cos(), sin(), tan()

# ⚠️ CRITICAL: NO SPACES IN EXPRESSIONS!
# ✅ CORRECT: (100+100*cos(115°))
# ❌ WRONG:   (100 + 100*cos(115°))
# Expressions are parsed as single tokens - spaces will break them!

# ===== ARITHMETIC EXPRESSIONS =====
point : 50+30 100-20 -> P          # Simple arithmetic: (80, 80)
point : 100/2 200*0.5 -> Q         # Division and multiplication: (50, 100)
circle : O 50+25 -> c              # Radius = 75

# ===== TRIGONOMETRIC FUNCTIONS =====
# Use cos(), sin(), tan() with degree or radian values
# Default unit is degree (like angle notation)

# Degree notation (° or deg):
point : cos(30°) sin(30°) -> A     # Point at (cos(30°), sin(30°)) ≈ (0.866, 0.5)
point : cos(60°) sin(60°) -> B     # Point at (cos(60°), sin(60°)) ≈ (0.5, 0.866)
point : cos(45deg) sin(45deg) -> C # Same as cos(45°) sin(45°)

# Radian notation (rad or r):
point : cos(1.5708rad) sin(1.5708rad) -> D  # cos(π/2), sin(π/2) ≈ (0, 1)
point : cos(0.5236r) sin(0.5236r) -> E      # cos(30° in rad), sin(30° in rad)

# Default (no unit = degree):
point : cos(30) sin(30) -> F       # Same as cos(30°) sin(30°)

# ===== COMBINED EXPRESSIONS (Arithmetic + Trig) =====
# This is the most powerful feature!
# Create points at polar coordinates directly: (r*cos(θ), r*sin(θ))

point : 100*cos(0°) 100*sin(0°) -> P0       # Point at distance 100, angle 0°
point : 100*cos(45°) 100*sin(45°) -> P45    # Point at distance 100, angle 45°
point : 100*cos(90°) 100*sin(90°) -> P90    # Point at distance 100, angle 90°
point : 100*cos(135°) 100*sin(135°) -> P135 # Point at distance 100, angle 135°

# Equilateral triangle using polar coordinates
point : 0 0 -> O
point : 100*cos(0°) 100*sin(0°) -> A       # 0°
point : 100*cos(120°) 100*sin(120°) -> B   # 120°
point : 100*cos(240°) 100*sin(240°) -> C   # 240°
polygon : A B C -> triangle AB BC CA

# Regular hexagon
point : 0 0 -> Center
point : 80*cos(0°) 80*sin(0°) -> H1        # 0°
point : 80*cos(60°) 80*sin(60°) -> H2      # 60°
point : 80*cos(120°) 80*sin(120°) -> H3    # 120°
point : 80*cos(180°) 80*sin(180°) -> H4    # 180°
point : 80*cos(240°) 80*sin(240°) -> H5    # 240°
point : 80*cos(300°) 80*sin(300°) -> H6    # 300°

# Complex expressions with parentheses (NO SPACES!)
point : (50+30*cos(45°)) (50+30*sin(45°)) -> Q    # Offset center at (50,50), radius 30
point : (100+100*cos(115°)) (0+100*sin(115°)) -> P # Complex parenthesized expression
point : (2*sin(30°)+3*cos(60°)) (10*tan(45°)) -> R # Mixed expression with parens

# Circle with calculated radius
point : 0 0 -> O
circle : O 100*sin(60°) -> c    # Radius = 100 * sin(60°) ≈ 86.6
```

**Common Trigonometric Values (for reference):**
| Angle | cos | sin | tan |
|-------|-----|-----|-----|
| 0°    | 1   | 0   | 0   |
| 30°   | √3/2 ≈ 0.866 | 1/2 = 0.5 | 1/√3 ≈ 0.577 |
| 45°   | √2/2 ≈ 0.707 | √2/2 ≈ 0.707 | 1 |
| 60°   | 1/2 = 0.5 | √3/2 ≈ 0.866 | √3 ≈ 1.732 |
| 90°   | 0   | 1   | undefined |
| 120°  | -0.5 | √3/2 ≈ 0.866 | -√3 ≈ -1.732 |
| 180°  | -1  | 0   | 0   |
| 240°  | -0.5 | -√3/2 ≈ -0.866 | √3 ≈ 1.732 |
| 270°  | 0   | -1  | undefined |
| 300°  | 0.5 | -√3/2 ≈ -0.866 | -√3 ≈ -1.732 |

**Expression Evaluation Rules:**
1. **NO SPACES**: Expressions must not contain spaces! `(100+50)` ✅  `(100 + 50)` ❌
2. **Existing objects take priority**: If you defined `point : 0 0 -> 100`, then `100` refers to that point, not the number
3. **Expressions are evaluated**: `100*cos(45°)` is calculated automatically
4. **Simple numbers**: `100` without operators is treated as a numeric literal
5. **Safe evaluation**: Only +, -, *, /, (), and trig functions are allowed

**Use cases:**
- Creating points on circles at specific angles (polar coordinates)
- Regular polygons (equilateral triangles, squares, hexagons, etc.)
- Positioning points with calculated offsets
- Complex geometric constructions with precise angles

### 13. Arithmetic
```
sum : a b -> c                   # Addition
minus : a b -> c                 # Subtraction
product : a b -> c               # Multiplication
ratio : a b -> c                 # Division
```

### 14. Verification (OPTIONAL)
```
equality : A A -> expr0          # Optional equality check
prove : expr0 -> result          # Optional prove statement
```

**Note**: These lines are OPTIONAL and not required for basic constructions.

### 15. IMPORTANT CONSTRAINTS

**What DSL CAN do:**
- ✅ Construct points, lines, circles, polygons
- ✅ Transform objects (rotate, mirror, etc.)
- ✅ Find intersections, midpoints
- ✅ Create geometric objects

**What DSL CANNOT do:**
- ❌ Assert angle values: `equality : angle_A 80` (WRONG!)
- ❌ Assert parallel: `parallel : line1 line2` (WRONG!)
- ❌ Assert perpendicular: `perpendicular : line1 line2` (WRONG!)
- ❌ Directly enforce constraints

**How to handle constraints:**
- If problem says "angle A = 80°", construct the geometry to naturally have that angle (use `rotate` command)
- If problem says "AB∥CD", construct parallel lines using `parallel_line` command
- If problem says "AB⊥CD", use `orthogonal_line` command to construct perpendicular

## Validation-Friendly Patterns

### Pattern 1: Explicitly Create Mentioned Objects

If problem mentions specific geometric objects, create them explicitly:

```
# Problem mentions "segment AB" and "segment BC"
point :  -> A
point :  -> B
point :  -> C
segment : A B -> seg_AB    # Explicitly create
segment : B C -> seg_BC    # Explicitly create
```

### Pattern 2: Points on Segments

If problem says "D is on AB":

```
# Method 1: Fixed coordinates (if A and B are fixed)
point : 0 0 -> A
point : 200 0 -> B
point : 80 0 -> D          # D between A and B on x-axis

# Method 2: Using intersection with another line
point :  -> A
point :  -> B
line : A B -> line_AB
# ... construct another line that intersects AB
intersect : line_AB other_line -> D
```

### Pattern 3: Parallel Lines

If problem says "DE∥BC":

```
# Method 1: Use parallel_line command (RECOMMENDED)
point :  -> B
point :  -> C
line : B C -> line_BC
point :  -> D
parallel_line : D line_BC -> line_DE
# Now line_DE passes through D and is parallel to BC

# Method 2: Create second point E on the parallel line
point :  -> B
point :  -> C
segment : B C -> seg_BC
point :  -> D
parallel_line : D seg_BC -> line_DE
point : line_DE -> E
# Now line DE is parallel to BC

# Method 3: Use rotation (for equal-length parallel segments)
point :  -> B
point :  -> C
vector : B C -> vec_BC
point :  -> D
translate : D vec_BC -> E
# Now DE is parallel to BC and has same length
```

### Pattern 4: Creating Triangles

Always use explicit segments for triangles (DO NOT use polygon command):

```
point :  -> A
point :  -> B
point :  -> C
segment : A B -> AB
segment : B C -> BC
segment : C A -> CA
```

This creates all three sides of the triangle explicitly.

### Pattern 5: Angles with Specific Values

```
# Create angle of 60° using rotation
point : 0 0 -> A
point : 100 0 -> B
rotate : B 60° A -> C
# Now angle CAB = 60°
```

### Validation Checklist:

Before finalizing your DSL, check:
- [ ] All points mentioned in problem are created
- [ ] All segments mentioned in problem are created (or points exist)
- [ ] All lines mentioned in problem are created (or points exist)
- [ ] All polygons mentioned in problem are created explicitly
- [ ] All circles mentioned in problem are created explicitly
- [ ] Conditions (parallel, perpendicular, angles) are satisfied geometrically
- [ ] Points "on segments/lines" are positioned correctly
- [ ] DSL ends with prove statement (equality : A A -> expr0, prove : expr0 -> result)

## Common Patterns

### Creating Parallel Lines:
```
# Method 1: Using parallel_line command (RECOMMENDED)
point :  -> A
point :  -> B
line : A B -> line_AB
point :  -> C
parallel_line : C line_AB -> line_CD
# line_CD passes through C and is parallel to line_AB

# Method 2: With segments
point :  -> A
point :  -> B
segment : A B -> seg_AB
point :  -> C
parallel_line : C seg_AB -> line_CD
```

### Creating Perpendicular Lines:
```
point :  -> A
point :  -> B
line : A B -> line_AB
point :  -> C
orthogonal_line : C line_AB -> perp_line
```

### Creating a Triangle:
```
point :  -> A
point :  -> B
point :  -> C
polygon : A B C -> triangle side_c side_a side_b
```

### Angle Bisector:
```
angle : A B C -> angle_ABC
angular_bisector : A B C -> bisector
```

### Rotating a Point:
```
point :  -> Center
const int 60 -> deg
point :  -> P
rotate : P deg Center -> P_rotated
```

## Critical Rules

1. **Order matters**: Define objects before using them
2. **Labels**: Use descriptive names (Center, line_AB, not x, y, z)
3. **Outputs**: Polygon command outputs: polygon, then sides in reverse order
4. **Random vs Fixed**: Use `point :  -> A` for unconstrained points

## Error Analysis and Image Observation

### When DSL Execution Fails

**READ THE ERROR MESSAGE:**
- Line number tells you WHERE the problem is
- Error type tells you WHAT went wrong
- Hints tell you HOW to fix it

**Common Error Types:**
- `UNDEFINED ELEMENT`: You used something before defining it
- `DUPLICATE LABEL`: You defined something twice
- `UNKNOWN COMMAND`: Command doesn't exist or wrong input types
- `OUTPUT COUNT MISMATCH`: Wrong number of outputs for command
- `MISSING ARROW`: Forgot `->` in command

### When You Have a Rendered Image

**THE IMAGE IS YOUR MOST IMPORTANT FEEDBACK!**

It shows exactly what your DSL code created. Check:

1. **Points**: Are all required points visible? Are they in correct positions?
2. **Segments**: Are all required segments drawn? Any missing connections?
3. **Circles**: Are circles present? Correct centers and radii?
4. **Overall shape**: Does it match the problem requirements?

**Example Image Analysis:**
```
Problem requires: Triangle ABC with segments AB, BC, CA
Image shows:
  ✓ Points A, B, C are visible
  ✓ Segments AB and BC are drawn
  ✗ Segment CA is MISSING

Fix: Add line `segment : C A -> CA`
```

**Use the image to verify your fixes:**
- After each change, compare new image with requirements
- If image is closer to goal, you're making progress
- If image is worse or unchanged, try different approach

## Common Errors

❌ **Using undefined object**:
```
line : A B -> line_AB  # Error: A and B not defined
```

✅ **Correct**:
```
point :  -> A
point :  -> B
line : A B -> line_AB
```

❌ **Using undefined object**:
```
circle : O 50 -> c  # Error: O not defined
```

✅ **Correct**:
```
point :  -> O
circle : O 50 -> c
```

❌ **Using polygon command**:
```
polygon : A B C -> triangle side_c side_a side_b  # Error: polygon is forbidden!
```

✅ **Correct - use explicit segments**:
```
segment : A B -> AB
segment : B C -> BC
segment : C A -> CA
```

